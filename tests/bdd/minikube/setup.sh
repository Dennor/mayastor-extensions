#!/usr/bin/env bash

# -o errexit: abort script if one command fails
# -o errtrace: the ERR trap is inherited by shell functions
# -o pipefail: entire command fails if pipe fails
# -o history: record shell history
set -o errexit -o errtrace -o pipefail -o history
# ERR trap
trap 'die "failed minikube setup"' ERR
trap 'cleanup_and_exit "$?"' EXIT

SCRIPT_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]:-"$0"}")")"
ROOT_DIR="$SCRIPT_DIR/../../.."
UTILS_DIR="$ROOT_DIR/scripts/utils"

# Imports
source "$UTILS_DIR/log.sh"
source "$UTILS_DIR/advisory_lock.sh"

cleanup_and_exit() {
  local -r status=${1}

  cleanup_workspace
  unlock_cleanup_config_file
  exit "$status"
}

# Removes workspace temporary directory.
cleanup_workspace() {
  if [ -n "${WORKSPACE}" ]; then
    rm -rf "${WORKSPACE}"
    echo "Removed directory ${WORKSPACE}."
  fi
}

# Exit with error status and print error.
die() {
  local -r msg=$1
  local -r return=${2:-1}

  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  log_fatal "$msg" "$return"
}

# Unlocks the cleanup config by removing the lock file.
unlock_cleanup_config_file() {
  if [ -n "$cleanup_config_initialized" ]; then
    advisory_lock_remove "$CLEANUP_CONFIG_FILE" "$CLEANUP_CONFIG_FILE_LOCK" "setup"
    cleanup_config_initialized=
  fi
}

# Create/initialize a new cleanup config file, also take a lock on for use on this script exclusively.
new_cleanup_config() {
  advisory_lock_acquire "$CLEANUP_CONFIG_FILE" "$CLEANUP_CONFIG_FILE_LOCK" "setup"

  >"$CLEANUP_CONFIG_FILE"
  yq -i ". head_comment=\"This file is auto-generated by the 'setup.sh' \
script to keep track of installed tools/prerequisites.
This is done so that the 'cleanup.sh' script removes only assets from the \
system which were installed
by the setup.sh, and not assets which were pre-existing in the system.\"" \
"$CLEANUP_CONFIG_FILE"

  yq -i ".cleanupAble=[]" "$CLEANUP_CONFIG_FILE"
}

# This is the actual API for the cleanup config, and only this function should be used. This
# consumes new_cleanup_config() and lock_cleanup_config_file().
prepend_cleanup_script() {
  local -r script=${1}

  if ! [ -f "$CLEANUP_CONFIG_FILE" ] || [ -z "$cleanup_config_initialized"  ]; then
    new_cleanup_config || die "failed to create file at $CLEANUP_CONFIG_FILE"
    cleanup_config_initialized=1
  fi

  yq -i ".cleanupAble = [\"$script\"] + .cleanupAble" "$CLEANUP_CONFIG_FILE"
}

# Print usage options for this script.
print_help() {
  cat <<EOF
Usage: $(basename "${0}") [OPTIONS]

Options:
  -h, --help                      Display this text.
  --kubernetes-version <version>  Specify the version of kubernetes.
  -p, --skip-prerequisites        Skip installing cri-dockerd and containernetworking plugins before creating
                                  minikube cluster.
  -y, --assume-yes                Assume the answer 'Y' for all interactive questions.
  -k, --skip-kube-context-switch  Skip switching kubectl cluster to the created minikube cluster's context.

Examples:
  $(basename "${0}") --kubernetes-version v1.25.11
EOF
}

# Parse arguments.
parse_args() {
  while test $# -gt 0; do
    arg="$1"
    case "$arg" in
    --kubernetes-version)
      test $# -lt 2 && die "missing value for the optional argument '$arg'."
      KUBERNETES_VERSION="${2}"
      shift
      ;;
    --kubernetes-version=*)
      KUBERNETES_VERSION="${arg#*=}"
      ;;
    -p | --skip-prerequisites)
      SKIP_PREREQUISITES=1
      ;;
    -y | --assume-yes)
      ASSUME_YES=1
      ;;
    -k | --skip-kube-context-switch)
      SKIP_KUBE_CONTEXT_SWITCH=1
      ;;
    -h* | --help*)
      print_help
      exit 0
      ;;
    *)
      _PRINT_HELP=yes die "unexpected argument '$arg'" 1
      ;;
    esac
    shift
  done
}

# Run command and expect success, or else exit with error.
must_succeed_command() {
  local -r error="${2:-command \'${1}\' failed}"
  ${1} || die "${error}"
}

# Check for command in PATH, else exit with error.
must_exists_in_path() {
  local -r error="${2:-command ${1} not present in PATH}"
  must_succeed_command "which ${1}" "${error}"
}

# Get latest release tag (not un-released) for a GitHub repo using GitHub's api.
github_latest_version_tag() {
  local -r github_org=${1}
  local -r github_repo=${2}

  local -r tag_name=$(${CURL} \
    -H "Accept: application/vnd.github+json" \
    https://api.github.com/repos/"${github_org}"/"${github_repo}"/releases/latest | ${JQ} '.tag_name')

  echo -n "${tag_name}"
}

# Get asset url for a GitHub release asset for a GitHub repo's latest release, using GitHub's api.
github_asset_url_from_latest_release() {
  local -r github_org=${1}
  local -r github_repo=${2}
  local -r release_asset_regex=${3}

  local -r url=$(${CURL} \
    -H "Accept: application/vnd.github+json" \
    https://api.github.com/repos/"${github_org}"/"${github_repo}"/releases/latest | ${JQ} \
    ".assets[] | select(.name? | match(\"${release_asset_regex}\")).url")

  echo -n "${url}"
}

# Get GitHub asset binary for a GitHub release asset for a GitHub repo, using GitHub's api.
github_asset_binary() {
  local -r github_asset_url=${1}
  local -r workspace=${2}
  local -r output_filepath=${3}

  cd "${workspace}"
  ${CURL} \
    -H "Accept: application/octet-stream" \
    "${github_asset_url}" \
    -o "${output_filepath}"
  cd - >/dev/null
}

# TODO: Use nix derivations for all prerequisites.
# Install prerequisites for minikube which aren't directly available from nixpkgs.
install_prerequisites() {
  local -r os=${1}
  local -r arch=${2}
  local -r workspace=${3}

  case "$os" in
  "GNU/Linux")
    case "$arch" in
    "x86_64")
      # Check if nix-shell prerequisites are present in PATH.
      for bin in "${NIX_SHELL_PREREQUISITES[@]}"; do
        must_exists_in_path "${bin}" >/dev/null
      done

      echo "Installing prerequisites for $os-$arch..."

      # Install cri-dockerd, if not installed.
      local cri_dockerd_error
      which cri-dockerd &>/dev/null || cri_dockerd_error=$?
      if [ -n "${cri_dockerd_error}" ]; then
        echo "Downloading latest version of cri-dockerd..."

        local -r url=$(github_asset_url_from_latest_release \
          "Mirantis" "cri-dockerd" "^(cri-dockerd-[0-9]+.[0-9]+.[0-9]+.amd64.tgz)$")
        github_asset_binary "${url}" "${workspace}" "cri-dockerd.tgz"
        tar -xf "${workspace}"/cri-dockerd.tgz -C "${workspace}"
        mkdir -p "$PREREQUISITES_BIN_DIR"
        install -o root -g root -m 0755 "${workspace}"/cri-dockerd/cri-dockerd "$PREREQUISITES_BIN_DIR"

        must_exists_in_path "cri-dockerd" "failed to install cri-dockerd" >/dev/null

        # Cleanup entry for cri-dockerd binary.
        prepend_cleanup_script "# Removes the cri-dockerd binary
rm -f $PREREQUISITES_BIN_DIR/cri-dockerd"

        echo "Downloaded latest version of cri-dockerd."
      fi
      # Check if cri-docker.socket systemd service is active. While this is extremely
      # unlikely if cri-dockerd wasn't already installed, it is possible.
      local cri_dockerd_service_error
      systemctl is-active --quiet cri-docker.socket || cri_dockerd_service_error=$?
      if [ -n "${cri_dockerd_service_error}" ]; then
        # Download systemd service files
        local -r cri_dockerd_version="v$(cri-dockerd --version 2>&1 | awk '{print $2}')"
        local -r systemd_service_files_url="https://raw.githubusercontent.com/Mirantis/cri-dockerd/${cri_dockerd_version}/packaging/systemd"
        cd "${workspace}"
        ${CURL} "${systemd_service_files_url}"/cri-docker.service -o cri-docker.service
        ${CURL} "${systemd_service_files_url}"/cri-docker.socket -o cri-docker.socket
        cd - >/dev/null
        install "${workspace}"/cri-docker.{service,socket} /etc/systemd/system
        sed -i -e "s,/usr/bin/cri-dockerd,$PREREQUISITES_BIN_DIR/cri-dockerd," /etc/systemd/system/cri-docker.service
        systemctl daemon-reload
        systemctl enable --now --quiet cri-docker.socket
        systemctl is-active --quiet cri-docker.socket || die "failed to set up cri-dockerd systemd service" 1

        # Cleanup entry for cri-docker.socket systemd service
        prepend_cleanup_script "# Disables and stops the systemd services
systemctl disable --now --quiet cri-docker.socket
systemctl disable --now --quiet cri-docker
systemctl daemon-reload
# Delete the service and configuration files for the systemd services
rm -rf /etc/systemd/system/cri-docker.{service,service.d,socket}"

        echo "Enabled cri-dockerd.socket systemd service."
      fi


      local -r cni_plugin_install_dir="/opt/cni/bin"
      local cni_plugins_error
      # If the directory exists, then the stat command will succeed and output the filetype.
      # If it is a directory, then the filetype will be "directory"
      local -r cni_plugin_filetype=$(stat ${cni_plugin_install_dir} --printf=%F 2>/dev/null) \
        && [[ "$cni_plugin_filetype" == "directory" ]] \
        || cni_plugins_error=$?

      if [ -n "$cni_plugins_error" ]; then
        # Install container-network-plugins.
        echo "Installing container-network-plugins..."
        local -r cni_plugin_version=$(github_latest_version_tag "containernetworking" "plugins")
        local -r cni_plugin_tar="cni-plugins-linux-amd64-${cni_plugin_version}.tgz"
        cd "${workspace}"
        ${CURL} \
          -O "https://github.com/containernetworking/plugins/releases/download/${cni_plugin_version}/${cni_plugin_tar}"
        mkdir -p "${cni_plugin_install_dir}"
        tar -xf "${cni_plugin_tar}" -C "${cni_plugin_install_dir}"
        cd - >/dev/null

        #Cleanup entry for containernetworking-plugins.
        prepend_cleanup_script "rm -rf ${cni_plugin_install_dir}"

        echo "Installed container-network-plugins."
      fi

      echo "Installed prerequisites for $os-$arch."
      ;;
      # TODO: Needs implementation.
    "arm64" | "aarch64")
      die "the 'install_prerequisites' option is not implemented for ${os}-${arch}" 1
      ;;
    *)
      die "the 'install_prerequisites' option does not support the arch ${arch} for OS ${os}" 1
      ;;
    esac
    ;;
  "Darwin")
    case "$arch" in
    # TODO: Needs implementation.
    "x86_64")
      die "the 'install_prerequisites' option is not implemented for ${os}-${arch}" 1
      ;;
      # TODO: Needs implementation.
    "arm64")
      die "the 'install_prerequisites' option is not implemented for ${os}-${arch}" 1
      ;;
    *)
      die "the 'install_prerequisites' option does not support the arch ${arch} for OS ${os}" 1
      ;;
    esac
    ;;
  *)
    die "the 'install_prerequisites' option does not support the OS ${os}" 1
    ;;
  esac
}

# Prints the version of the kubectl client.
kubectl_version() {
  kubectl version --client -o json | ${JQ} '.clientVersion.gitVersion'
}

# Pull in kubectl from hosted binary as mixing nix-shell and nix-env is not idiomatic.
pull_and_install_kubectl_binary() {
  local -r os=${1}
  local -r arch=${2}
  local -r workspace=${3}
  local -r kubernetes_version=${4}

  local dl_link_os_path
  local dl_link_arch_path
  case "$os" in
  "GNU/Linux")
    dl_link_os_path="linux"
    ;;
  "Darwin")
    dl_link_os_path="darwin"
    ;;
  *)
    die "the 'install_kubectl' option does not support the OS ${os}" 1
    ;;
  esac
  case "$arch" in
  "x86_64")
    dl_link_arch_path="amd64"
    ;;
  "arm64" | "aarch64")
    dl_link_arch_path="arm64"
    ;;
  *)
    die "the 'install_kubectl' option does not support the arch ${arch}" 1
    ;;
  esac

  # Pulling kubectl binary.
  cd "${workspace}"
  ${CURL} -O "https://dl.k8s.io/release/${kubernetes_version}/bin/${dl_link_os_path}/${dl_link_arch_path}/kubectl"
  cd - >/dev/null

  mkdir -p "$PREREQUISITES_BIN_DIR"
  install -o root -g root -m 0755 "${workspace}"/kubectl "${PREREQUISITES_BIN_DIR}"

  [[ "$(kubectl_version)" == "$kubernetes_version" ]] || die "failed to install kubectl $kubernetes_version"
  echo "Installed kubectl $kubernetes_version."

  # Cleanup entry kubectl.
  prepend_cleanup_script "# Removes the kubectl binary
rm -f $PREREQUISITES_BIN_DIR/kubectl"
}

# Set up kubectl if not already present in PATH, and if not the correct version.
set_up_kubectl() {
  local -r os=${1}
  local -r arch=${2}
  local -r workspace=${3}
  local -r kubernetes_version=${4}

  # The OR to this is true to that the script doesn't register an error. It is entirely possible
  # that kubectl doesn't exist in PATH.
  local -r kubectl_path=$(which kubectl 2>/dev/null)  || true
  if [ -n "${kubectl_path}" ]; then
    if [[ "$(kubectl_version)" != "$kubernetes_version" ]]; then
      pull_and_install_kubectl_binary "$os" "$arch" "$workspace" "$kubernetes_version"
    else
      echo "kubectl ${kubernetes_version} already exists at ${kubectl_path}."
    fi
  else
    pull_and_install_kubectl_binary "$os" "$arch" "$workspace" "$kubernetes_version"
  fi
}

# Consts
CURL="curl -fSsL"
JQ="jq -r"
CLEANUP_CONFIG_FILE="${SCRIPT_DIR}/.cleanup_config.yaml"
CLEANUP_CONFIG_FILE_LOCK="${CLEANUP_CONFIG_FILE}.lock"
KUBERNETES_VERSION="v1.25.11"
SKIP_PREREQUISITES=
PREREQUISITES_BIN_DIR="${SCRIPT_DIR}/bin"
ASSUME_YES=
SKIP_KUBE_CONTEXT_SWITCH=

# Parse CLI args.
parse_args "$@"

NIX_SHELL_PREREQUISITES=("conntrack" "minikube" "crictl" "curl" "jq" "yq" "awk" "systemctl" "docker")
# Gather platform info.
OS=$(must_succeed_command "uname -o")
ARCH=$(must_succeed_command "uname -m")
# Directory to store downloaded files.
WORKSPACE=$(must_succeed_command "mktemp -d -t mayastor-extensions-minikube-setup-XXXXX" \
  "failed to create workspace directory")
echo "Created workspace directory ${WORKSPACE}."

# Vars
cleanup_config_initialized=


# Install cri-dockerd and containernetworking-plugins.
[ -z "${SKIP_PREREQUISITES}" ] && install_prerequisites "$OS" "$ARCH" "$WORKSPACE"

# Set up minikube.
if [ -z "${ASSUME_YES}" ]; then
  log_to_stderr "======================"
  log_warn "Starting minikube. This may add a new kubernetes cluster context to your kubeconfig file at ${HOME}/.kube/config."
  read -rp "Do you want to proceed? (Y/N): " confirm_minikube && [[ $confirm_minikube == [yY] ]] || exit 1
fi
echo "Starting minikube cluster with Kubernetes ${KUBERNETES_VERSION}..."
minikube start \
  --kubernetes-version=${KUBERNETES_VERSION} \
  --cni=calico \
  --driver=none \
  --install-addons=false \
  --keep-context=true \
  --force >/dev/null || die "failed to start minikube cluster" 1
echo "Started minikube cluster!"
# Cleanup entry for minikube profile.
prepend_cleanup_script "# Delete minikube assets
minikube delete"

# Set up kubectl.
if [ -z "${ASSUME_YES}" ]; then
  log_to_stderr "======================"
  log_warn "Setting up kubectl. This may replace your existing kubectl binary."
  read -rp "Do you want to proceed? (Y/N): " confirm_kubectl && [[ $confirm_kubectl == [yY] ]] || exit 1
fi
echo "Setting up kubectl ${KUBERNETES_VERSION}..."
set_up_kubectl "$OS" "$ARCH" "$WORKSPACE" "$KUBERNETES_VERSION"
echo "Set up kubectl ${KUBERNETES_VERSION}."

# Switch kubectl cluster context to the minikube cluster.
if [ -n "${SKIP_KUBE_CONTEXT_SWITCH}" ]; then
  echo "Skipped kubectl cluster context switch to 'minikube'."
else
  # The OR to this is true to that the script doesn't register an error. It is entirely possible
  # that there is no kube context set.
  existing_context=$(kubectl config current-context 2>/dev/null) || true
  echo -n "kubectl: "
  must_succeed_command "kubectl config use-context minikube" "failed to switch cluster context to 'minikube'"

  # Cleanup entry for kube context switch
  if [ -n "$existing_context" ]; then
    prepend_cleanup_script "# Reinstate previous kube context
kubectl config use-context ${existing_context}"
  fi
fi
